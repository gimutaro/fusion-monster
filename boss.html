<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ホラークリーチャー - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff6b6b;
            text-shadow: 0 0 10px #ff0000;
            z-index: 100;
            font-size: 14px;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">
        クリック&ドラッグで回転<br>
        不気味な生き物が見つめています...
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, creature, eyeGroup;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isDragging = false;
        let previousMouseX = 0, previousMouseY = 0;

        function init() {
            // シーン設定
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

            // カメラ設定
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 12);
            camera.lookAt(0, 0, 0);

            // レンダラー設定
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a0a0a);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // クリーチャーグループ
            creature = new THREE.Group();

            // 胴体（有機的な形状）
            const bodyGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            // 歪ませる
            const positions = bodyGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                const noise = Math.sin(x * 3) * Math.cos(y * 3) * 0.2;
                positions.setXYZ(i, x + noise, y + noise * 0.5, z + noise);
            }
            bodyGeometry.computeVertexNormals();

            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x8b7355,
                shininess: 10,
                flatShading: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            creature.add(body);

            // 頭部（兎のような耳付き）
            const headGeometry = new THREE.SphereGeometry(1, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({
                color: 0xa08070,
                shininess: 5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2;
            head.scale.set(1.2, 1.3, 1);
            creature.add(head);

            // 不気味な耳（左）
            const earGeometry = new THREE.ConeGeometry(0.3, 2, 8);
            const earMaterial = new THREE.MeshPhongMaterial({
                color: 0x7a6050,
                side: THREE.DoubleSide
            });
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.7, 3.5, 0.2);
            leftEar.rotation.z = -0.3;
            creature.add(leftEar);

            // 耳（右）- わざと長さを変える
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.7, 3.3, 0.2);
            rightEar.rotation.z = 0.3;
            rightEar.scale.y = 1.3;
            creature.add(rightEar);

            // 目のグループ（マウスに追従）
            eyeGroup = new THREE.Group();
            eyeGroup.position.y = 2;
            creature.add(eyeGroup);

            // 複数の不気味な目
            const eyePositions = [
                { x: -0.5, y: 0.3, z: 0.9, scale: 1 },
                { x: 0.5, y: 0.3, z: 0.9, scale: 1 },
                { x: 0, y: 0.6, z: 0.8, scale: 0.6 },
                { x: -0.3, y: -0.2, z: 0.95, scale: 0.4 }
            ];

            eyePositions.forEach(pos => {
                // 白目
                const eyeWhiteGeometry = new THREE.SphereGeometry(0.25 * pos.scale, 16, 16);
                const eyeWhiteMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffee,
                    emissive: 0x222200
                });
                const eyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
                eyeWhite.position.set(pos.x, pos.y, pos.z);

                // 瞳孔
                const pupilGeometry = new THREE.SphereGeometry(0.15 * pos.scale, 16, 16);
                const pupilMaterial = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.3
                });
                const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                pupil.position.set(pos.x, pos.y, pos.z + 0.2 * pos.scale);
                pupil.userData.isEye = true;
                pupil.userData.offset = { x: pos.x, y: pos.y, z: pos.z };

                eyeGroup.add(eyeWhite);
                eyeGroup.add(pupil);
            });

            // 触手のような手
            for (let i = 0; i < 4; i++) {
                const tentacle = createTentacle();
                const angle = (i / 4) * Math.PI * 2;
                const radius = 1.3;
                tentacle.position.x = Math.cos(angle) * radius;
                tentacle.position.y = -0.5;
                tentacle.position.z = Math.sin(angle) * radius;
                tentacle.rotation.z = angle;
                creature.add(tentacle);
            }

            scene.add(creature);

            // ライティング
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xff4444, 0.8);
            spotLight.position.set(5, 10, 5);
            spotLight.castShadow = true;
            scene.add(spotLight);

            const spotLight2 = new THREE.SpotLight(0x4444ff, 0.5);
            spotLight2.position.set(-5, 5, -5);
            scene.add(spotLight2);

            // 地面
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -3;
            ground.receiveShadow = true;
            scene.add(ground);

            // イベントリスナー
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
        }

        function createTentacle() {
            const tentacleGroup = new THREE.Group();
            const segments = 5;
            
            for (let i = 0; i < segments; i++) {
                const size = 0.15 - (i * 0.02);
                const segmentGeometry = new THREE.SphereGeometry(size, 8, 8);
                const segmentMaterial = new THREE.MeshPhongMaterial({
                    color: 0x6b5b4b,
                    shininess: 20
                });
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segment.position.y = -i * 0.3;
                segment.position.x = Math.sin(i * 0.5) * 0.2;
                tentacleGroup.add(segment);
            }
            
            return tentacleGroup;
        }

        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isDragging) {
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // クリーチャーの呼吸のような動き
            creature.scale.y = 1 + Math.sin(time * 1.5) * 0.05;
            creature.scale.x = 1 + Math.sin(time * 1.5 + Math.PI) * 0.03;
            creature.scale.z = 1 + Math.sin(time * 1.5 + Math.PI) * 0.03;

            // 回転
            creature.rotation.y += (targetRotationY - creature.rotation.y) * 0.05;
            creature.rotation.x += (targetRotationX - creature.rotation.x) * 0.05;

            if (!isDragging) {
                creature.rotation.y += 0.003;
            }

            // 目がマウスを追う
            eyeGroup.children.forEach(child => {
                if (child.userData.isEye) {
                    const offset = child.userData.offset;
                    child.position.x = offset.x + mouseX * 0.1;
                    child.position.y = offset.y + mouseY * 0.1;
                    
                    // 不気味な光
                    child.material.emissiveIntensity = 0.3 + Math.sin(time * 3) * 0.2;
                }
            });

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>